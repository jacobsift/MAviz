# streamlit_app.py
import streamlit as st
import pandas as pd
import plotly.express as px
import os
import numpy as np

# --- Configuration ---
# Path to the input CSV file generated by the previous script
# Make sure this path is correct relative to where you run the streamlit app
DATA_FILE_PATH = 'final_300_mimics_all_original_data.csv' 
# Define columns of interest
MIMIC_PEPTIDE_COL = 'mimic_Peptide'
HLA_COL = 'MHC'
MIMIC_AFF_COL = 'mimic_Aff(nM)'
CANCER_AFF_COL = 'cancer_Aff(nM)'
MIMIC_EL_COL = 'mimic_%Rank_EL'
CANCER_EL_COL = 'cancer_%Rank_EL'

# --- Helper Functions ---

@st.cache_data # Cache the data loading to improve performance
def load_data(file_path):
    """Loads the data from the specified CSV file."""
    if not os.path.exists(file_path):
        st.error(f"Error: Data file not found at {file_path}")
        st.stop() # Stop execution if file is missing
    try:
        df = pd.read_csv(file_path)
        print(f"Successfully loaded data with shape: {df.shape}") # Server-side print
        # Basic check for required columns
        required_cols = [MIMIC_PEPTIDE_COL, HLA_COL, MIMIC_AFF_COL, CANCER_AFF_COL, MIMIC_EL_COL, CANCER_EL_COL]
        if not all(col in df.columns for col in required_cols):
            st.error(f"Error: Missing one or more required columns in the data file. Needed: {required_cols}")
            st.stop()
        # Convert relevant columns to numeric, coercing errors
        for col in [MIMIC_AFF_COL, CANCER_AFF_COL, MIMIC_EL_COL, CANCER_EL_COL]:
             if df[col].dtype == 'object':
                 df[col] = pd.to_numeric(df[col], errors='coerce')
        # Clean HLA names (remove potential whitespace)
        if df[HLA_COL].dtype == 'object':
            df[HLA_COL] = df[HLA_COL].str.strip()
        return df
    except Exception as e:
        st.error(f"Error loading or processing data file: {e}")
        st.stop()

def reshape_for_plotting(df, selected_metric):
    """Reshapes data for easier plotting of mimic vs cancer values."""
    id_vars = [MIMIC_PEPTIDE_COL, HLA_COL] # Columns to keep
    # Add any other columns you might want to filter/group by later
    other_cols = [col for col in df.columns if col not in [MIMIC_AFF_COL, CANCER_AFF_COL, MIMIC_EL_COL, CANCER_EL_COL] and col in id_vars]
    
    if selected_metric == 'Affinity (nM)':
        value_vars = [MIMIC_AFF_COL, CANCER_AFF_COL]
        var_name = 'Source'
        value_name = 'Affinity (nM)'
        log_y = True # Affinity often benefits from log scale
    elif selected_metric == '%Rank EL':
        value_vars = [MIMIC_EL_COL, CANCER_EL_COL]
        var_name = 'Source'
        value_name = '%Rank EL'
        log_y = False # Rank is usually linear
    else:
        return pd.DataFrame(), False # Return empty df if metric invalid

    # Ensure value_vars exist
    value_vars = [col for col in value_vars if col in df.columns]
    if not value_vars:
        st.warning(f"Could not find columns for metric '{selected_metric}'")
        return pd.DataFrame(), False

    # Use pd.melt to reshape
    df_melted = pd.melt(df, 
                        id_vars=id_vars + [c for c in other_cols if c not in id_vars], # Keep relevant identifiers
                        value_vars=value_vars, 
                        var_name=var_name, 
                        value_name=value_name)

    # Clean up the 'Source' column names
    df_melted[var_name] = df_melted[var_name].replace({
        MIMIC_AFF_COL: 'Mimic', CANCER_AFF_COL: 'Cancer',
        MIMIC_EL_COL: 'Mimic', CANCER_EL_COL: 'Cancer'
    })
    
    # Drop rows where the value is NaN (important after melting)
    df_melted.dropna(subset=[value_name], inplace=True)

    return df_melted, log_y, value_name, var_name


# --- Streamlit App Layout ---

st.set_page_config(layout="wide") # Use wide layout for better plot visibility
st.title("🧬 Mimic Peptide Binding Explorer")
st.markdown("Explore Affinity (nM) and %Rank EL distributions for selected mimics across different HLA types.")

# Load the data
df_original = load_data(DATA_FILE_PATH)

# --- Sidebar for User Inputs ---
st.sidebar.header("⚙️ Filters")

# Mimic Peptide Selection
mimic_list = ['All'] + sorted(df_original[MIMIC_PEPTIDE_COL].unique().tolist())
selected_mimics = st.sidebar.multiselect(
    "Select Mimic Peptide(s):", 
    options=mimic_list, 
    default=['All'] 
)

# Handle 'All' selection for mimics
if 'All' in selected_mimics:
    filtered_df = df_original.copy()
else:
    filtered_df = df_original[df_original[MIMIC_PEPTIDE_COL].isin(selected_mimics)]

# HLA Type Selection (based on filtered mimics)
available_hlas = ['All'] + sorted(filtered_df[HLA_COL].unique().tolist())
selected_hlas = st.sidebar.multiselect(
    "Select HLA Type(s):",
    options=available_hlas,
    default=['All']
)

# Handle 'All' selection for HLAs
if 'All' not in selected_hlas:
    filtered_df = filtered_df[filtered_df[HLA_COL].isin(selected_hlas)]

# Metric Selection
metric_options = ['Affinity (nM)', '%Rank EL']
selected_metric = st.sidebar.radio(
    "Select Metric to Visualize:",
    options=metric_options,
    index=0 # Default to Affinity
)

st.sidebar.markdown("---") # Separator
st.sidebar.info(f"Displaying data for **{filtered_df[MIMIC_PEPTIDE_COL].nunique()}** mimics and **{filtered_df[HLA_COL].nunique()}** HLAs.")


# --- Main Panel for Visualizations ---

if filtered_df.empty:
    st.warning("No data matches the current filter selections.")
else:
    st.header(f"Distribution of {selected_metric}")

    # Reshape data for plotting
    df_melted, use_log_y, value_col_name, source_col_name = reshape_for_plotting(filtered_df, selected_metric)

    if df_melted.empty:
        st.warning(f"No valid data points found for the selected metric '{selected_metric}' with current filters.")
    else:
        
        # --- Plot 1: Distribution by HLA Type (Box Plot) ---
        st.subheader(f"{selected_metric} Distribution by HLA Type")
        
        if df_melted[HLA_COL].nunique() > 0:
            # Determine number of HLAs to decide plot height
            num_hlas = df_melted[HLA_COL].nunique()
            plot_height = max(400, 30 * num_hlas) # Adjust height based on number of categories
            
            try:
                # Use different sorting based on metric
                category_order = sorted(df_melted[HLA_COL].unique()) if not use_log_y else df_melted.groupby(HLA_COL)[value_col_name].median().sort_values().index.tolist()

                fig_box = px.box(
                    df_melted, 
                    x=value_col_name, 
                    y=HLA_COL, 
                    color=source_col_name,
                    title=f"{selected_metric} Distribution per HLA (Mimic vs Cancer)",
                    labels={value_col_name: selected_metric, HLA_COL: "HLA Type", source_col_name: "Source"},
                    orientation='h', # Horizontal for better label reading with many HLAs
                    log_x=use_log_y, # Use log scale for x-axis if appropriate
                    category_orders={HLA_COL: category_order}, # Sort HLAs
                    height=plot_height,
                    points=False # 'outliers' or False or 'all' or 'suspectedoutliers'
                )
                fig_box.update_layout(yaxis={'categoryorder':'total ascending'} if not use_log_y else {'categoryorder':'median ascending'}) # Sort y-axis
                st.plotly_chart(fig_box, use_container_width=True)
                
                # Optional: Violin plot (can be busy with many HLAs)
                # fig_violin = px.violin(...) 
                # st.plotly_chart(fig_violin, use_container_width=True)

            except Exception as e:
                st.error(f"An error occurred while generating the box plot: {e}")

        else:
            st.info("Select specific HLAs or ensure data exists for the current selection to view distribution by HLA.")

        # --- Plot 2: Overall Distribution (Histogram/Density) ---
        st.subheader(f"Overall {selected_metric} Distribution")
        
        try:
            fig_hist = px.histogram(
                df_melted, 
                x=value_col_name, 
                color=source_col_name,
                title=f"Overall Distribution of {selected_metric} (Mimic vs Cancer)",
                labels={value_col_name: selected_metric, source_col_name: "Source"},
                marginal="rug", # Adds rug plot to show individual points
                histnorm='percent', # Show percentage instead of count
                barmode='overlay',
                opacity=0.7,
                log_x=use_log_y
            )
            fig_hist.update_layout(xaxis_title=selected_metric, yaxis_title="Percentage")
            st.plotly_chart(fig_hist, use_container_width=True)
        except Exception as e:
             st.error(f"An error occurred while generating the histogram: {e}")

        # --- Display Filtered Data Table ---
        st.subheader("Filtered Data View")
        st.dataframe(filtered_df)


# --- How to Run ---
st.sidebar.markdown("---")
st.sidebar.header("How to Run")
st.sidebar.markdown("""
1.  **Save:** Save this code as a Python file (e.g., `streamlit_app.py`).
2.  **Install Libraries:** If you don't have them, install Streamlit and Plotly:
    ```bash
    pip install streamlit pandas plotly
    ```
3.  **Place Data:** Make sure the `final_300_mimics_all_original_data.csv` file is located correctly relative to the script (as defined in `DATA_FILE_PATH`). The current code expects it in `./comprehensive_mimic_analysis/`.
4.  **Run:** Open your terminal, navigate to the directory where you saved the file, and run:
    ```bash
    streamlit run streamlit_app.py
    ```
5.  **Interact:** A new tab should open in your web browser with the application. Use the sidebar to filter and explore!
""")

